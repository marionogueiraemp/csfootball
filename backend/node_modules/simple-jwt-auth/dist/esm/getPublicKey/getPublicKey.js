var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { SimpleJwtAuthError } from '../SimpleJwtAuthError';
import { getUnauthedClaims } from '../getUnauthedClaims';
import { getUnauthedHeaderClaims } from '../getUnauthedHeaderClaims';
import { discoverJwksUriFromAuthServerMetadata } from './discoverJwksUriFromAuthServerMetadata';
import { extractPublicKeyFromJwksUri } from './extractPublicKeyFromJwksUri';
import { cachePublicKey, getPublicKeyFromCache } from './publicKeyCache';
export class GetPublicKeyOfTokenError extends SimpleJwtAuthError {
    constructor({ reason }) {
        const message = `
${reason}

Can not get public key of token
    `.trim();
        super(message);
    }
}
/**
 * gets the public key used to sign the token
 *
 * note
 * - caches the results to prevent redundant network requests
 * - supports oauth discovery flow, to discover the jwks endpoint from the issuer
 * - supports manual flow, to explicitly define the jwks endpoint for issuers who dont support discovery
 */
export const getPublicKey = ({ token, jwksUri: jwksUriInput, cache = { ttlInSeconds: 300 }, }) => __awaiter(void 0, void 0, void 0, function* () {
    // grab the issuer from the token
    const claims = getUnauthedClaims({ token });
    const issuer = claims.iss;
    if (!issuer)
        throw new GetPublicKeyOfTokenError({
            reason: 'Issuer not defined on the token (i.e., no `claims.iss`).',
        });
    // grab the keyId from the token
    const headerClaims = getUnauthedHeaderClaims({ token });
    const keyId = headerClaims.kid;
    if (!keyId)
        throw new GetPublicKeyOfTokenError({
            reason: 'KeyId is not defined on the token (i.e., no `header.kid`)',
        });
    // try to return the public key if we already have it in the cache
    const cachedKey = getPublicKeyFromCache({ issuer, keyId });
    if (cachedKey)
        return cachedKey; // if we got it, we got it
    // otherwise, lookup the public key
    const jwksUri = jwksUriInput !== null && jwksUriInput !== void 0 ? jwksUriInput : (yield discoverJwksUriFromAuthServerMetadata({ claims }));
    const publicKey = yield extractPublicKeyFromJwksUri({
        headerClaims,
        jwksUri,
    });
    // cache the public key for future lookups (to save on the two HTTP calls)
    cachePublicKey({
        issuer,
        keyId,
        publicKey,
        ttlInSeconds: cache.ttlInSeconds,
    });
    // return the pem cert
    return publicKey; // this is the public key
});
//# sourceMappingURL=getPublicKey.js.map
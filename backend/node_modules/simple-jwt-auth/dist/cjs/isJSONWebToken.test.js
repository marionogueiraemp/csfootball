"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const castBase64UrlToBase64_1 = require("./base64Url/castBase64UrlToBase64");
const isJSONWebToken_1 = require("./isJSONWebToken");
const redactSignature_1 = require("./redactSignature");
const exampleValidTokenShape = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c';
describe('isJSONWebToken', () => {
    it('should return true for a valid token', () => {
        const isJwt = (0, isJSONWebToken_1.isJSONWebToken)(exampleValidTokenShape);
        expect(isJwt).toEqual(true);
    });
    it('should return false for gibberish', () => {
        const isJwt = (0, isJSONWebToken_1.isJSONWebToken)('__TOKEN__');
        expect(isJwt).toEqual(false);
    });
    it('should return false if not base64Url encoded', () => {
        const base64Token = exampleValidTokenShape
            .split('.')
            .map((part) => (0, castBase64UrlToBase64_1.castBase64UrlToBase64)(part)) // decode each part
            .join('.');
        const isJwt = (0, isJSONWebToken_1.isJSONWebToken)(base64Token);
        expect(isJwt).toEqual(false);
    });
    it('should return true even if signature is redacted', () => {
        const exampleTokenWithRedactedSignature = (0, redactSignature_1.redactSignature)({
            token: exampleValidTokenShape,
        });
        const isJwt = (0, isJSONWebToken_1.isJSONWebToken)(exampleTokenWithRedactedSignature);
        expect(isJwt).toEqual(true);
    });
});
//# sourceMappingURL=isJSONWebToken.test.js.map
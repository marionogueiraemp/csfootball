"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPublicKey = exports.GetPublicKeyOfTokenError = void 0;
const SimpleJwtAuthError_1 = require("../SimpleJwtAuthError");
const getUnauthedClaims_1 = require("../getUnauthedClaims");
const getUnauthedHeaderClaims_1 = require("../getUnauthedHeaderClaims");
const discoverJwksUriFromAuthServerMetadata_1 = require("./discoverJwksUriFromAuthServerMetadata");
const extractPublicKeyFromJwksUri_1 = require("./extractPublicKeyFromJwksUri");
const publicKeyCache_1 = require("./publicKeyCache");
class GetPublicKeyOfTokenError extends SimpleJwtAuthError_1.SimpleJwtAuthError {
    constructor({ reason }) {
        const message = `
${reason}

Can not get public key of token
    `.trim();
        super(message);
    }
}
exports.GetPublicKeyOfTokenError = GetPublicKeyOfTokenError;
/**
 * gets the public key used to sign the token
 *
 * note
 * - caches the results to prevent redundant network requests
 * - supports oauth discovery flow, to discover the jwks endpoint from the issuer
 * - supports manual flow, to explicitly define the jwks endpoint for issuers who dont support discovery
 */
const getPublicKey = ({ token, jwksUri: jwksUriInput, cache = { ttlInSeconds: 300 }, }) => __awaiter(void 0, void 0, void 0, function* () {
    // grab the issuer from the token
    const claims = (0, getUnauthedClaims_1.getUnauthedClaims)({ token });
    const issuer = claims.iss;
    if (!issuer)
        throw new GetPublicKeyOfTokenError({
            reason: 'Issuer not defined on the token (i.e., no `claims.iss`).',
        });
    // grab the keyId from the token
    const headerClaims = (0, getUnauthedHeaderClaims_1.getUnauthedHeaderClaims)({ token });
    const keyId = headerClaims.kid;
    if (!keyId)
        throw new GetPublicKeyOfTokenError({
            reason: 'KeyId is not defined on the token (i.e., no `header.kid`)',
        });
    // try to return the public key if we already have it in the cache
    const cachedKey = (0, publicKeyCache_1.getPublicKeyFromCache)({ issuer, keyId });
    if (cachedKey)
        return cachedKey; // if we got it, we got it
    // otherwise, lookup the public key
    const jwksUri = jwksUriInput !== null && jwksUriInput !== void 0 ? jwksUriInput : (yield (0, discoverJwksUriFromAuthServerMetadata_1.discoverJwksUriFromAuthServerMetadata)({ claims }));
    const publicKey = yield (0, extractPublicKeyFromJwksUri_1.extractPublicKeyFromJwksUri)({
        headerClaims,
        jwksUri,
    });
    // cache the public key for future lookups (to save on the two HTTP calls)
    (0, publicKeyCache_1.cachePublicKey)({
        issuer,
        keyId,
        publicKey,
        ttlInSeconds: cache.ttlInSeconds,
    });
    // return the pem cert
    return publicKey; // this is the public key
});
exports.getPublicKey = getPublicKey;
//# sourceMappingURL=getPublicKey.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSignatureVerified = void 0;
const castBase64UrlToBase64_1 = require("../base64Url/castBase64UrlToBase64");
const castJwtAlgToCryptoAlg_1 = require("./castJwtAlgToCryptoAlg");
const importCrypto_1 = require("./importCrypto");
const isEllipticSigningAlgorithm_1 = require("./isEllipticSigningAlgorithm");
/**
 * determines whether a signature can be verified for a given payload and public key
 */
const isSignatureVerified = ({ alg, signature, payload, publicKey, }) => {
    const crypto = (0, importCrypto_1.importCrypto)();
    // convert the alg the token said it was signed by to an alg name that crypto understands
    const cryptoAlg = (0, castJwtAlgToCryptoAlg_1.castJwtAlgToCryptoAlg)(alg);
    // attempt to verify by using the signature
    const unescapedSignatureClaim = (0, castBase64UrlToBase64_1.castBase64UrlToBase64)(signature); // JWT's are url encoded, so that they are safe to pass in urls (i.e., base64URL format). crypto only supports normal base64, so we decode base64Url into base64 for interop
    const verified = crypto
        .createVerify(cryptoAlg)
        .update(payload)
        .verify({
        key: publicKey,
        dsaEncoding: (0, isEllipticSigningAlgorithm_1.isEllipticSigningAlgorithm)(alg) ? 'ieee-p1363' : undefined, // if its an elliptic signing algorithm, we must specify the specific encoding format, since node defaults to DER while jwt's use IEEE; https://stackoverflow.com/questions/39499040/generating-ecdsa-signature-with-node-js-crypto?rq=3
    }, unescapedSignatureClaim, 'base64');
    // return the result
    return verified;
};
exports.isSignatureVerified = isSignatureVerified;
//# sourceMappingURL=isSignatureVerified.js.map
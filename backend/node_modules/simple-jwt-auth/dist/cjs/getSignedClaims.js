"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignedClaims = void 0;
const getUnauthedClaims_1 = require("./getUnauthedClaims");
const verifyTokenSignature_1 = require("./verification/verifyTokenSignature");
const verifyTokenSigningAlgo_1 = require("./verification/verifyTokenSigningAlgo");
/**
 * Simply check that the token was signed correctly, without checking anything else, and return the claims if so.
 *
 * NOTE: this does _not_ mean that the token should be trusted. All this confirms is that some server, somewhere, at some point in time, signed these claims. This token could still be from a malicious auth server, issued for a different application, or issued years ago - stolen - and no longer valid.
 *
 * Use `getAuthedClaims` in settings where you must trust the claims of a token.
 */
const getSignedClaims = ({ token, publicKey, }) => {
    // check that the token was signed by an asymmetric algorithm - otherwise, this token can't be used securely in a distributed system. (i.e., there is no "publicKey" in a symmetric signing algo)
    (0, verifyTokenSigningAlgo_1.verifyTokenSigningAlgo)({ token });
    // verify that the token was signed by the issuer
    (0, verifyTokenSignature_1.verifyTokenSignature)({ token, publicKey });
    // return the claims of the token, as with the above checks we have authenticated those claims
    const tokenClaims = (0, getUnauthedClaims_1.getUnauthedClaims)({ token });
    return tokenClaims; // they are now authed
};
exports.getSignedClaims = getSignedClaims;
//# sourceMappingURL=getSignedClaims.js.map
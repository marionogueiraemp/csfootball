"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const getTokenFromAuthorizationCookieWithCSRFProtection_1 = require("./getTokenFromAuthorizationCookieWithCSRFProtection");
const getTokenFromAuthorizationHeader_1 = require("./getTokenFromAuthorizationHeader");
const getTokenFromHeaders_1 = require("./getTokenFromHeaders");
jest.mock('./getTokenFromAuthorizationCookieWithCSRFProtection');
const getTokenFromAuthorizationCookieWithCSRFProtectionMock = getTokenFromAuthorizationCookieWithCSRFProtection_1.getTokenFromAuthorizationCookieWithCSRFProtection;
getTokenFromAuthorizationCookieWithCSRFProtectionMock.mockReturnValue(null);
jest.mock('./getTokenFromAuthorizationHeader');
const getTokenFromAuthorizationHeaderMock = getTokenFromAuthorizationHeader_1.getTokenFromAuthorizationHeader;
getTokenFromAuthorizationHeaderMock.mockReturnValue(null);
const exampleHeaders = '__EXAMPLE_HEADERS__'; // not a real object, since we mock out the things that actually look at it
describe('getTokenFromHeaders', () => {
    beforeEach(() => jest.resetAllMocks());
    it('should return the token from AuthCookie, if we found one - even if we could find one from AuthHeader', () => {
        getTokenFromAuthorizationCookieWithCSRFProtectionMock.mockReturnValueOnce('__TOKEN_FROM_AUTH_COOKIE__');
        getTokenFromAuthorizationHeaderMock.mockReturnValueOnce('__TOKEN_FROM_AUTH_HEADER__');
        const token = (0, getTokenFromHeaders_1.getTokenFromHeaders)({ headers: exampleHeaders });
        expect(token).toEqual('__TOKEN_FROM_AUTH_COOKIE__');
    });
    it('should return the token from AuthHeader, if we found one but did not find one for AuthCookie', () => {
        getTokenFromAuthorizationCookieWithCSRFProtectionMock.mockReturnValueOnce(null);
        getTokenFromAuthorizationHeaderMock.mockReturnValueOnce('__TOKEN_FROM_AUTH_HEADER__');
        const token = (0, getTokenFromHeaders_1.getTokenFromHeaders)({ headers: exampleHeaders });
        expect(token).toEqual('__TOKEN_FROM_AUTH_HEADER__');
    });
    it('should return null if token was not found from both AuthCookie and AuthHeader', () => {
        getTokenFromAuthorizationCookieWithCSRFProtectionMock.mockReturnValueOnce(null);
        getTokenFromAuthorizationHeaderMock.mockReturnValueOnce(null);
        const token = (0, getTokenFromHeaders_1.getTokenFromHeaders)({ headers: exampleHeaders });
        expect(token).toEqual(null);
    });
});
//# sourceMappingURL=getTokenFromHeaders.test.js.map
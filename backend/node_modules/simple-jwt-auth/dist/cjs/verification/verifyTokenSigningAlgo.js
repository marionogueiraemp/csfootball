"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyTokenSigningAlgo = void 0;
const getUnauthedHeaderClaims_1 = require("../getUnauthedHeaderClaims");
const isAsymmetricSigningAlgorithm_1 = require("../signingAlgorithm/isAsymmetricSigningAlgorithm");
const JwtVerificationError_1 = require("./JwtVerificationError");
/**
 * only asymmetric signing algorithms can be securely used in a distributed authentication strategy.
 *
 * why? symmetric signing algorithms do not have public keys, so third parties have no way of verifying the authenticity of a token - unless the private key is made public, in which case anyone can issue verifiable claims and the strategy is no longer secure.
 *
 * this library supports distributed authentication strategies, so symmetric keys are forbidden
 */
const verifyTokenSigningAlgo = ({ token }) => {
    const unauthedHeaderClaims = (0, getUnauthedHeaderClaims_1.getUnauthedHeaderClaims)({ token });
    if (!(0, isAsymmetricSigningAlgorithm_1.isAsymmetricSigningAlgorithm)(unauthedHeaderClaims.alg))
        throw new JwtVerificationError_1.JwtVerificationError({
            reason: `tokens must be signed with asymmetric signing algorithms for secure distributed jwt authentication. found \`token.header.alg = ${unauthedHeaderClaims.alg}\` instead.`,
        });
};
exports.verifyTokenSigningAlgo = verifyTokenSigningAlgo;
//# sourceMappingURL=verifyTokenSigningAlgo.js.map
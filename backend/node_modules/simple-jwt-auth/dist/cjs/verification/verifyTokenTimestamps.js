"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyTokenTimestamps = void 0;
const getUnauthedClaims_1 = require("../getUnauthedClaims");
const isExpiredToken_1 = require("../isExpiredToken");
const JwtVerificationError_1 = require("./JwtVerificationError");
const verifyTokenTimestamps = ({ token }) => {
    const unauthedClaims = (0, getUnauthedClaims_1.getUnauthedClaims)({ token });
    const now = new Date();
    // check that the token has not expired
    if (!unauthedClaims.exp)
        throw new JwtVerificationError_1.JwtVerificationError({
            reason: 'no expiration claim on the token. this is very unsafe',
        });
    const hasExpired = (0, isExpiredToken_1.isExpiredToken)(token); // note: we moved "isExpiredToken" logic out since it is a common usecase by callers of the package
    if (hasExpired)
        throw new JwtVerificationError_1.JwtVerificationError({
            reason: 'token has expired (see `token.claims.exp`)',
        });
    // check that its not too early, if the token specified a "not before" timestamp
    if (unauthedClaims.nbf) {
        const isTooEarly = (0, isExpiredToken_1.isBefore)(now, (0, isExpiredToken_1.fromUnixTime)(unauthedClaims.nbf));
        if (isTooEarly)
            throw new JwtVerificationError_1.JwtVerificationError({
                reason: 'token can not be used yet (see `token.claims.nbf`)',
            });
    }
};
exports.verifyTokenTimestamps = verifyTokenTimestamps;
//# sourceMappingURL=verifyTokenTimestamps.js.map